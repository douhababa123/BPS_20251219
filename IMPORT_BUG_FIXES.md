# 导入功能Bug修复报告

## 📅 修复日期
2025-11-24

---

## 🐛 问题1：能力定义导入失败

### 错误信息
```
❌ 导入失败: 保存技能失败: Could not find the 'owner_engineer' column of 'skills' in the schema cache
```

### 根本原因
**数据库表结构不匹配**

1. **数据库表结构**（`DATABASE_RESTRUCTURE_FINAL.sql`）：
   ```sql
   create table if not exists skills (
     id bigint generated by default as identity primary key,
     module_id int not null,
     module_name text not null,
     skill_name text not null,
     skill_code text unique,
     description text,
     display_order int default 0,
     is_active boolean default true,
     created_at timestamptz default now(),
     updated_at timestamptz default now(),
     unique(module_id, skill_name)
   );
   ```
   ❌ **没有 `owner_engineer` 列**

2. **解析器定义**（`skillDefinitionParser.ts`）：
   ```typescript
   export interface SkillDefinition {
     module_id: number;
     module_name: string;
     skill_name: string;
     display_order: number;
     owner_engineer?: string;  // ❌ 多余字段
   }
   ```

3. **插入逻辑**：
   ```typescript
   skills.push({
     module_id: moduleId,
     module_name: moduleName,
     skill_name: skillName,
     display_order: skills.length + 1,
     owner_engineer: engineer || undefined,  // ❌ 尝试写入不存在的列
   });
   ```

### 解决方案
**移除 `owner_engineer` 字段**

#### 修改1：接口定义
```typescript
// 修改前
export interface SkillDefinition {
  module_id: number;
  module_name: string;
  skill_name: string;
  display_order: number;
  owner_engineer?: string;  // ❌
}

// 修改后
export interface SkillDefinition {
  module_id: number;
  module_name: string;
  skill_name: string;
  display_order: number;
}
```

#### 修改2：解析逻辑
```typescript
// 修改前
const moduleName = String(row[moduleCol] || '').trim();
const skillName = String(row[typeCol] || '').trim();
const engineer = engineerCol >= 0 ? String(row[engineerCol] || '').trim() : undefined;  // ❌

skills.push({
  module_id: moduleId,
  module_name: moduleName,
  skill_name: skillName,
  display_order: skills.length + 1,
  owner_engineer: engineer || undefined,  // ❌
});

// 修改后
const moduleName = String(row[moduleCol] || '').trim();
const skillName = String(row[typeCol] || '').trim();

skills.push({
  module_id: moduleId,
  module_name: moduleName,
  skill_name: skillName,
  display_order: skills.length + 1,
});
```

---

## 🐛 问题2：能力评估导入失败

### 错误信息
```
发现 1 个错误，需要修正
: 未找到"Department"和"Name"列，请检查Excel格式
```

### 根本原因
**列名查找逻辑不够灵活**

1. **原代码问题**：
   ```typescript
   // 只在skillNameRow（第3行，索引3）查找
   for (let i = 0; i < rawData[dataStartRow]?.length || 0; i++) {
     const cell = String(rawData[skillNameRow]?.[i] || '').toLowerCase();
     if (cell.includes('department') || cell.includes('部门')) {
       deptColIndex = i;
     }
     if (cell.includes('name') || cell.includes('姓名')) {
       nameColIndex = i;
     }
   }
   ```
   
   **问题**：
   - ❌ 只在第4行（skillNameRow=3）查找
   - ❌ 没有处理大小写和空格变化
   - ❌ 没有回退方案（如果第4行没有列名）

2. **实际Excel格式可能的变化**：
   - 列名可能在第4行、第5行或第6行
   - 列名可能有空格：`" Department "`, `"Name "`
   - 列名可能大小写不同：`"DEPARTMENT"`, `"Name"`
   - 列名可能根本没有，需要根据数据位置推断

### 解决方案
**多层次查找策略**

#### 修改：增强的列查找逻辑
```typescript
// 1. 先在skillNameRow（第4行）查找
for (let i = 0; i < (rawData[skillNameRow]?.length || 0); i++) {
  const cell = String(rawData[skillNameRow]?.[i] || '').toLowerCase().trim();
  if ((cell.includes('department') || cell.includes('部门')) && deptColIndex === -1) {
    deptColIndex = i;
  }
  if ((cell.includes('name') || cell.includes('姓名') || cell === 'name') && nameColIndex === -1) {
    nameColIndex = i;
  }
}

// 2. 如果没找到，在ctMarkerRow（第5行）查找
if (deptColIndex === -1 || nameColIndex === -1) {
  for (let i = 0; i < (rawData[ctMarkerRow]?.length || 0); i++) {
    const cell = String(rawData[ctMarkerRow]?.[i] || '').toLowerCase().trim();
    if ((cell.includes('department') || cell.includes('部门')) && deptColIndex === -1) {
      deptColIndex = i;
    }
    if ((cell.includes('name') || cell.includes('姓名') || cell === 'name') && nameColIndex === -1) {
      nameColIndex = i;
    }
  }
}

// 3. 如果还是没找到，根据数据行推断（前两列通常是部门和姓名）
if (deptColIndex === -1 || nameColIndex === -1) {
  const firstDataRow = rawData[dataStartRow];
  if (firstDataRow && firstDataRow.length >= 2) {
    const col0 = String(firstDataRow[0] || '').trim();
    const col1 = String(firstDataRow[1] || '').trim();
    
    // 如果前两列有数据，假设第0列是部门，第1列是姓名
    if (col0 && col1 && deptColIndex === -1 && nameColIndex === -1) {
      deptColIndex = 0;
      nameColIndex = 1;
      console.log('推断：第0列=部门，第1列=姓名');
    }
  }
}

// 4. 提供详细错误信息
if (deptColIndex === -1 || nameColIndex === -1) {
  const row3Content = rawData[skillNameRow]?.slice(0, 5).map((c: any) => String(c || '')).join(' | ');
  const row4Content = rawData[ctMarkerRow]?.slice(0, 5).map((c: any) => String(c || '')).join(' | ');
  errors.push({ 
    message: `未找到"Department"和"Name"列。\n第4行前5列内容: ${row3Content}\n第5行前5列内容: ${row4Content}\n请确保前两列是部门和姓名。` 
  });
  return { success: false, data: null, errors, summary: { departments: 0, employees: 0, skills: 0, assessments: 0 } };
}
```

### 改进点
1. ✅ **多行查找**：第4行 → 第5行 → 数据行推断
2. ✅ **大小写不敏感**：`.toLowerCase()`
3. ✅ **去除空格**：`.trim()`
4. ✅ **多种匹配模式**：`includes()` + 完全匹配
5. ✅ **智能推断**：如果没有列名，根据前两列数据自动推断
6. ✅ **详细错误信息**：显示实际的行内容帮助调试

---

## 📊 修改文件统计

```
修改的文件：
  src/lib/skillDefinitionParser.ts
    - 移除 owner_engineer 字段定义
    - 移除 engineer 变量提取逻辑
    - 移除 owner_engineer 字段插入
    变更：-5行 代码简化

  src/lib/complexExcelParser.ts
    - 增强Department/Name列查找逻辑
    - 添加多层次查找策略
    - 添加智能推断机制
    - 改进错误提示信息
    变更：+53行 -18行 更健壮的查找
```

---

## ✅ 测试结果

### 编译测试
```bash
$ npm run build
✓ 2365 modules transformed.
✓ built in 3.76s
```
✅ **编译成功，无TypeScript错误**

### 预期修复效果

#### 能力定义导入
**修复前：**
```
❌ 导入失败: 保存技能失败: Could not find the 'owner_engineer' column
```

**修复后：**
```
✅ 成功导入 39 个能力定义
```

#### 能力评估导入
**修复前：**
```
❌ 发现 1 个错误：未找到"Department"和"Name"列
```

**修复后：**
- ✅ 情况1：列名在第4行 → 直接识别
- ✅ 情况2：列名在第5行 → 第二层查找识别
- ✅ 情况3：没有列名 → 根据前两列数据推断
- ✅ 情况4：仍然失败 → 提供详细错误（显示实际内容）

---

## 🎯 用户操作指南

### 能力定义导入（现在可用）
1. 进入"数据导入"页面
2. 选择"📋 能力定义导入"
3. 上传Excel文件（格式：编号 | 模块 | 类型 | 工程师）
   - 注意：工程师列会被忽略（数据库不存储此字段）
4. 点击"开始解析"
5. 确认导入
6. ✅ 应该显示"成功导入 XX 个能力定义"

### 能力评估导入（增强后）
1. 进入"数据导入"页面
2. 选择"📊 能力评估导入"
3. 上传横向矩阵Excel
   - 前两列应该是：部门 | 姓名
   - 列名可以是：Department/部门, Name/姓名，或者没有列名
   - 列名可以有空格和大小写变化
4. 点击"开始解析"
5. 查看解析结果
6. 确认导入
7. ✅ 应该成功导入评估数据

---

## 🔍 调试技巧

### 如果能力定义导入仍然失败
1. 检查数据库表结构：
   ```sql
   SELECT column_name, data_type 
   FROM information_schema.columns 
   WHERE table_name = 'skills';
   ```
2. 确认没有自定义字段要求

### 如果能力评估导入仍然失败
1. 查看控制台（F12）的日志：
   - 会显示"推断：第0列=部门，第1列=姓名"
2. 查看错误提示中的实际行内容
3. 确认Excel格式：
   - 第4行（索引3）：技能名称或列名
   - 第5行（索引4）：C/T标记或列名
   - 第6行起（索引5+）：数据行

---

## 📝 后续建议

### 短期
- [ ] 实际测试能力定义导入（使用真实39个能力的Excel）
- [ ] 实际测试能力评估导入（使用真实横向矩阵Excel）
- [ ] 根据实际情况继续优化列名识别

### 中期
- [ ] 考虑在前端添加Excel格式验证器（上传前预检查）
- [ ] 添加Excel模板下载功能
- [ ] 添加导入预览功能（显示解析后的数据预览）

### 长期
- [ ] 支持更多Excel格式变体
- [ ] 添加数据验证规则配置
- [ ] 支持增量导入（不覆盖现有数据）

---

## 🎉 总结

**两个关键Bug已修复：**

1. ✅ **能力定义导入**：移除数据库不存在的 `owner_engineer` 字段
2. ✅ **能力评估导入**：增强Department/Name列查找，支持多种格式

**用户现在应该能够：**
- 成功导入39个能力类型定义
- 成功导入横向矩阵格式的评估数据
- 看到更友好的错误提示（如果还有问题）

---

**请刷新页面后重新尝试导入！** 🚀
